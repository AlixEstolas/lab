Containers
- mini-VM that has all the packages needed to run a single application

Virtual Machine
- self-explanatory but in this context the containers are run in these virtual machines in a many-to-one relationship
(many containers : one VM)

Docker
- allows developers to containerize an application so that it can run on any computer without needing
any setup aside from Docker's

Load Balancing
- it allowed a cluster of virtual machines to have unique processes so that not all of them are
working on the same user request for example.

Managing Clusters
- was a hassle pre-Kubernetes because each VM had its own operating system needed specifically for
each container.

Kubernetes
- Allowed an easy way to give instructions to a cluster such as: when to scale up, when to scale down,
what is the maximum size, what is the minimum size, etc. It also provided its own load balancer.

Node
- It is a group of containers. It is what is essentially a "VM" under Kubernetes

Cluster
- Group of Nodes. A cluster has its own load-balancer called a "Control Panel"

Control Pane
- Handles the requests of the Developer giving instructions using Kubernetes

Pod
- Not a container but a collection of containers under Kubernetes. It containes
storage, networking, and containers.

API Server
- A Control plane has an API controller that listens to request from
the Rancher port

Scheduler
- A Control plane has a scheduler that handles the requests from the API Server. This is essentially
the equivalent of the "load-balancer"

Initcontainer
- A container that tests connections, makes sures that user-defined conditions are true before running the containers

Rancher
- is a Kubernetes client/server that we use to interface with Kubernetes

Deployment
- a deployment is a set of pods whose number depends on --replicas and image depends on --image

Replica
- when we deploy to Kubernetes we will often times have multiple pods of the same definition. -> replicaset=10

Replicaset
- a set of Replicas of a single pod definition
- should be managed by Kubernetes Deployments, user-managed Replica sets are discouraged

.spec.strategy.rollingUpdate.maxSurge: x% or x
- means that if you have 10 replicas and there is a surge, it will only add another
pod based on the % of the total replicas allowed or by the x amounts set. (25% or 1)

.spec.strategy.rollingUpdate.maxUnavailable: x% or x
- does not allow more pods to be unavailable than the amount set for this parameter

.spec.strategy.type: Recreate or RollingDeploy
- defines the type of deployment done when an update is applied

Recreate
- destroys ALL pods before deploying new pods

RollingDeploy
- deploys by batches so that an app can remain on while deploying

.spec.template.spec.containers.command: ["COMMANDS HERE","-c"]
- overrides the default command

.spec.template.spec.containers.args: ["ARGUMENTS HERE like sleep 5; exit 1"]
- is run after the default command
- ``sleep 5; exit 1`` means "sleep for 30 seconds then exit with an error"

What happens when Deployment fails IN RollingDeploy
- it will throw RunContainerError as status then restart but will not continue the deployment
to the other pods(50% of them if no max set)

Namespace
- logical grouping of resources.A mechanism of isolating resources within a single cluster